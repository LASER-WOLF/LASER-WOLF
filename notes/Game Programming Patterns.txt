///////////////////////////////////////////////////////////////////////////////
// This document contains notes for the book:
// "Game Programming Patterns" by Robert Nystrom
///////////////////////////////////////////////////////////////////////////////

  #0: INTRODUCTION

  #1: DESIGN PATTERNS REVISITED
    1.1: COMMAND ............ https://gameprogrammingpatterns.com/command.html
    1.2: FLYWEIGHT .......... https://gameprogrammingpatterns.com/flyweight.html
    1.3: OBSERVER ........... https://gameprogrammingpatterns.com/observer.html
    1.4: PROTOTYPE .......... https://gameprogrammingpatterns.com/prototype.html
    1.5: SINGLETON .......... https://gameprogrammingpatterns.com/singleton.html
    1.6: STATE .............. https://gameprogrammingpatterns.com/state.html
    
  #2: SEQUENCING PATTERNS
    2.1: DOUBLE BUFFER ...... https://gameprogrammingpatterns.com/double-buffer.html
    2.2: GAME LOOP .......... https://gameprogrammingpatterns.com/game-loop.html
    2.3: UPDATE METHOD ...... https://gameprogrammingpatterns.com/update-method.html

  #3: BEHAVIORAL PATTERNS
    3.1: BYTECODE ........... https://gameprogrammingpatterns.com/bytecode.html
    3.2: SUBCLASS SANDBOX ... https://gameprogrammingpatterns.com/subclass-sandbox.html
    3.3: TYPE OBJECT ........ https://gameprogrammingpatterns.com/type-object.html

  #4: DECOUPLING PATTERNS
    4.1: COMPONENT .......... https://gameprogrammingpatterns.com/component.html
    4.2: EVENT QUEUE ........ https://gameprogrammingpatterns.com/event-queue.html
    4.3: SERVICE LOCATOR .... https://gameprogrammingpatterns.com/service-locator.html

  #5: OPTIMIZATION PATTERNS
    5.1: DATA LOCALITY ...... https://gameprogrammingpatterns.com/data-locality.html
    5.2: DIRTY FLAG ......... https://gameprogrammingpatterns.com/dirty-flag.html
    5.3: OBJECT POOL ........ https://gameprogrammingpatterns.com/object-pool.html
    5.4: SPATIAL PARTION .... https://gameprogrammingpatterns.com/spatial-partition.html

///////////////////////////////////////////////////////////////////////////////
// #0 | INTRODUCTION                                                     p. 1
///////////////////////////////////////////////////////////////////////////////

 - Sections for each pattern:
   + Intent: description of a pattern in terms of the problem it intends to solve
   + Motivation: An example problem we will apply the pattern to
   + Pattern: Dry textbook description of the pattern
   + When to use it: When it is useful and when it should be avoided
   + Keep in mind: Consequences and risks when using the pattern
   + Sample code: A full implementation of the pattern in C++
   + Design Descisions: Different options to consider when applying a pattern
   + See Also: Relationship to other patterns and real world examples

 - Unlike concrete algorithms, a pattern is usually formless unless applied 
   to some specific problem. Each time you use a pattern, 
   you'll likely implement it differently
 
 - This book continues the process started by the Gang of Four of documenting
   and sharing the software patterns they saw.
   "Design Patterns: Elements of Reusable Object-Oriented Software"
   by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides


///////////////////////////////////////////////////////////////////////////////
// #1 | ARCHITECTURE, PERFORMANCE, AND GAMES                             p. 9
///////////////////////////////////////////////////////////////////////////////

 - Abstraction and decoupling make evolving your program faster and easier,
   but dont' waste time doing them unless you're confident the code in question
   needs that flexibility.
 
 - Think about design for performance throughout your development cycle, but
   put off the low-level, nitty-gritty optimizations that lock assumptions
   into your code until as late as possible.

 - Move quickly to explore your game's design space, but don't go so fast that
   you leave a mess behind you.

 - If you are going to ditch code, don't waste time making it pretty.


///////////////////////////////////////////////////////////////////////////////
// #2 | DESIGN PATTERNS REVISITED                                       p. 19
///////////////////////////////////////////////////////////////////////////////

 - A fresh look at selected patterns from the book "Design Patterns:
   Elements of Reusable Object-Oriented Software"


  2.1 | COMMAND                                                         p. 21
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 " Encapsulate a request as an object, thereby letting users parameterize 
   clients with different requests, queue or log requests, and support
   undoable operations. "
  
 - A command is a reified method call.
 
 - Commands are object-oriented replacements for callbacks


  2.2 | FLYWEIGHT                                                       p. 33
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 " Use sharing to support large numbers of fine-grained objects efficiently. "

 - Instead of storing say a texture and mesh for each instanste of a 3d game
   object we can instead store the mesh/texture as a model that can be shared
   between multiple game objects. The game object only stores a reference to
   the model. This is used togther with instanced rendering (GPU) to only send
   the three model data to the GPU once, even when rendering the same object
   thousands of times.

 - Seperates the object's data into two kinds. 
   1. The kind of data that is not specific to a single instance of that 
      object and be shared across multiple objects. 
      Also called intristic state. 
   2. The rest of the data is the extrinsic state. The stuff that's unique to
      a single instance.


  2.3 | OBSERVER                                                        p. 43
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 " Define a one-to-many dependency between objects so that when one object
   changes state, all its dependents are notified and updated automatically. "

 - One of the most widely used and widely known of 
   the original Gang of Four patterns.

 - Model-View-Controller architecture is using the Observer pattern

 - C# event keyword is Observer and it is in the core of Java

 - One piece of code can announce that something interesting happened without
   actually caring who receives the notification.

 - Example use case: Achievements

 - We can create a base class Observer and any class that want to be notified of
   events can derivce from this base class and become an observer.
   The object being observed is called the "subject".
   The subject base class stores a list of observers and exposes a public API for 
   modifying that list. It also has a protected method for notifying observers
   of events. The object that needs to send notifications just need to derive
   from the subject base class to send notifications to the observers.


  2.4 | PROTOTYPE                                                       p. 59
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 " Specify the kinds of objects to create using a prototypical instance,
   and create new objects by copying this prototype.

 - Example use case: Data in JSON files to avoid typing duplicate values
   over and over


  2.5 | SINGLETON                                                       p. 73
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 " Ensure a class has one instance, and provide a global point of 
   access to it "

 - Despite noble intentions, the Singleton pattern usually 
   does more harm than good.


  2.6 | STATE                                                           p. 87
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


///////////////////////////////////////////////////////////////////////////////
// #3 | SEQUENCING PATTERNS                                            p. 105
///////////////////////////////////////////////////////////////////////////////
 
 - ...


  3.1 | DOUBLE BUFFER                                                  p. 107
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  3.2 | GAME LOOP                                                      p. 123
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  3.3 | UPDATE METHOD                                                  p. 139
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


///////////////////////////////////////////////////////////////////////////////
// #4 | BEHAVIORAL PATTERNS                                            p. 153
///////////////////////////////////////////////////////////////////////////////
 
 - ...


  4.1 | BYTECODE                                                       p. 155
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  4.2 | SUBCLASS SANDBOX                                               p. 181
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  4.3 | TYPE OBJECT                                                    p. 193
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...




///////////////////////////////////////////////////////////////////////////////
// #5 | DECOUPLING PATTERNS                                            p. 211
///////////////////////////////////////////////////////////////////////////////
 
 - ...


  5.1 | COMPONENT                                                      p. 213
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  5.2 | EVENT QUEUE                                                    p. 233
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  5.3 | SERVICE LOCATOR                                                p. 251
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...




///////////////////////////////////////////////////////////////////////////////
// #6 | OPTIMIZATION PATTERNS                                         p. 267
///////////////////////////////////////////////////////////////////////////////
 
 - ...


  6.1 | DATA LOCALITY                                                  p. 269
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  6.2 | DIRTY FLAG                                                     p. 291
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  6.3 | OBJECT POOL                                                    p. 305
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


  6.4 | SPATIAL PARTION                                                p. 321
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
 - ...


